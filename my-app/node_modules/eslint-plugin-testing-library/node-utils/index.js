"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.findImportSpecifier = exports.isEmptyFunction = exports.getStatementCallExpression = exports.hasImportMatch = exports.getInnermostReturningFunction = exports.hasClosestExpectResolvesRejects = exports.getAssertNodeInfo = exports.getImportModuleName = exports.getFunctionName = exports.getReferenceNode = exports.getDeepestIdentifierNode = exports.getPropertyIdentifierNode = exports.getFunctionReturnStatementNode = exports.getInnermostFunctionScope = exports.getVariableReferences = exports.isPromiseHandled = exports.isPromisesArrayResolved = exports.isPromiseAllSettled = exports.isPromiseAll = exports.isPromiseIdentifier = exports.hasChainedThen = exports.hasThenProperty = exports.findClosestCallNode = exports.findClosestVariableDeclaratorNode = exports.findClosestCallExpressionNode = void 0;
const utils_1 = require("@typescript-eslint/utils");
const is_node_of_type_1 = require("./is-node-of-type");
__exportStar(require("./is-node-of-type"), exports);
const ValidLeftHandSideExpressions = [
    utils_1.AST_NODE_TYPES.CallExpression,
    utils_1.AST_NODE_TYPES.ClassExpression,
    utils_1.AST_NODE_TYPES.ClassDeclaration,
    utils_1.AST_NODE_TYPES.FunctionExpression,
    utils_1.AST_NODE_TYPES.Literal,
    utils_1.AST_NODE_TYPES.TemplateLiteral,
    utils_1.AST_NODE_TYPES.MemberExpression,
    utils_1.AST_NODE_TYPES.ArrayExpression,
    utils_1.AST_NODE_TYPES.ArrayPattern,
    utils_1.AST_NODE_TYPES.ClassExpression,
    utils_1.AST_NODE_TYPES.FunctionExpression,
    utils_1.AST_NODE_TYPES.Identifier,
    utils_1.AST_NODE_TYPES.JSXElement,
    utils_1.AST_NODE_TYPES.JSXFragment,
    utils_1.AST_NODE_TYPES.JSXOpeningElement,
    utils_1.AST_NODE_TYPES.MetaProperty,
    utils_1.AST_NODE_TYPES.ObjectExpression,
    utils_1.AST_NODE_TYPES.ObjectPattern,
    utils_1.AST_NODE_TYPES.Super,
    utils_1.AST_NODE_TYPES.ThisExpression,
    utils_1.AST_NODE_TYPES.TSNullKeyword,
    utils_1.AST_NODE_TYPES.TaggedTemplateExpression,
    utils_1.AST_NODE_TYPES.TSNonNullExpression,
    utils_1.AST_NODE_TYPES.TSAsExpression,
    utils_1.AST_NODE_TYPES.ArrowFunctionExpression,
];
function findClosestCallExpressionNode(node, shouldRestrictInnerScope = false) {
    if ((0, is_node_of_type_1.isCallExpression)(node)) {
        return node;
    }
    if (!(node === null || node === void 0 ? void 0 : node.parent)) {
        return null;
    }
    if (shouldRestrictInnerScope &&
        !ValidLeftHandSideExpressions.includes(node.parent.type)) {
        return null;
    }
    return findClosestCallExpressionNode(node.parent, shouldRestrictInnerScope);
}
exports.findClosestCallExpressionNode = findClosestCallExpressionNode;
function findClosestVariableDeclaratorNode(node) {
    if (!node) {
        return null;
    }
    if (utils_1.ASTUtils.isVariableDeclarator(node)) {
        return node;
    }
    return findClosestVariableDeclaratorNode(node.parent);
}
exports.findClosestVariableDeclaratorNode = findClosestVariableDeclaratorNode;
function findClosestCallNode(node, name) {
    if (!node.parent) {
        return null;
    }
    if ((0, is_node_of_type_1.isCallExpression)(node) &&
        utils_1.ASTUtils.isIdentifier(node.callee) &&
        node.callee.name === name) {
        return node;
    }
    else {
        return findClosestCallNode(node.parent, name);
    }
}
exports.findClosestCallNode = findClosestCallNode;
function hasThenProperty(node) {
    return ((0, is_node_of_type_1.isMemberExpression)(node) &&
        utils_1.ASTUtils.isIdentifier(node.property) &&
        node.property.name === 'then');
}
exports.hasThenProperty = hasThenProperty;
function hasChainedThen(node) {
    const parent = node.parent;
    if ((0, is_node_of_type_1.isCallExpression)(parent) && parent.parent) {
        return hasThenProperty(parent.parent);
    }
    return !!parent && hasThenProperty(parent);
}
exports.hasChainedThen = hasChainedThen;
function isPromiseIdentifier(node) {
    return utils_1.ASTUtils.isIdentifier(node) && node.name === 'Promise';
}
exports.isPromiseIdentifier = isPromiseIdentifier;
function isPromiseAll(node) {
    return ((0, is_node_of_type_1.isMemberExpression)(node.callee) &&
        isPromiseIdentifier(node.callee.object) &&
        utils_1.ASTUtils.isIdentifier(node.callee.property) &&
        node.callee.property.name === 'all');
}
exports.isPromiseAll = isPromiseAll;
function isPromiseAllSettled(node) {
    return ((0, is_node_of_type_1.isMemberExpression)(node.callee) &&
        isPromiseIdentifier(node.callee.object) &&
        utils_1.ASTUtils.isIdentifier(node.callee.property) &&
        node.callee.property.name === 'allSettled');
}
exports.isPromiseAllSettled = isPromiseAllSettled;
function isPromisesArrayResolved(node) {
    const closestCallExpression = findClosestCallExpressionNode(node, true);
    if (!closestCallExpression) {
        return false;
    }
    return (!!closestCallExpression.parent &&
        (0, is_node_of_type_1.isArrayExpression)(closestCallExpression.parent) &&
        (0, is_node_of_type_1.isCallExpression)(closestCallExpression.parent.parent) &&
        (isPromiseAll(closestCallExpression.parent.parent) ||
            isPromiseAllSettled(closestCallExpression.parent.parent)));
}
exports.isPromisesArrayResolved = isPromisesArrayResolved;
function isPromiseHandled(nodeIdentifier) {
    const closestCallExpressionNode = findClosestCallExpressionNode(nodeIdentifier, true);
    const suspiciousNodes = [nodeIdentifier, closestCallExpressionNode].filter(Boolean);
    for (const node of suspiciousNodes) {
        if (!(node === null || node === void 0 ? void 0 : node.parent)) {
            continue;
        }
        if (utils_1.ASTUtils.isAwaitExpression(node.parent)) {
            return true;
        }
        if ((0, is_node_of_type_1.isArrowFunctionExpression)(node.parent) ||
            (0, is_node_of_type_1.isReturnStatement)(node.parent)) {
            return true