{"version":3,"names":["_core","require","transformWithoutHelper","loose","path","state","pushComputedProps","pushComputedPropsLoose","pushComputedPropsSpec","node","build","declar","loop","block","body","ensureBlock","push","t","inherits","replaceParent","parentPath","replaceWithMultiple","remove","buildForOfLoose","template","statement","buildForOf","statements","scope","parent","left","id","intermediate","isIdentifier","isPattern","isMemberExpression","isVariableDeclaration","generateUidIdentifier","variableDeclaration","kind","variableDeclarator","declarations","identifier","name","buildCodeFrameError","type","iteratorKey","isArrayKey","LOOP_OBJECT","IS_ARRAY","OBJECT","right","INDEX","ID","INTERMEDIATE","isLabeledParent","isLabeledStatement","labeled","labeledStatement","label","stepKey","generateUid","stepValue","memberExpression","expressionStatement","assignmentExpression","ITERATOR_HAD_ERROR_KEY","ITERATOR_COMPLETION","ITERATOR_ERROR_KEY","ITERATOR_KEY","STEP_KEY","tryBody"],"sources":["../src/no-helper-implementation.ts"],"sourcesContent":["import { type PluginPass, template, types as t } from \"@babel/core\";\nimport type { NodePath } from \"@babel/traverse\";\n\n// This is the legacy implementation, which inlines all the code.\n// It must be kept for compatibility reasons.\n// TODO(Babel 8): Remove this file.\n\nexport default function transformWithoutHelper(\n  loose: boolean | void,\n  path: NodePath<t.ForOfStatement>,\n  state: PluginPass,\n) {\n  const pushComputedProps = loose\n    ? pushComputedPropsLoose\n    : pushComputedPropsSpec;\n\n  const { node } = path;\n  const build = pushComputedProps(path, state);\n  const declar = build.declar;\n  const loop = build.loop;\n  const block = loop.body as t.BlockStatement;\n\n  // ensure that it's a block so we can take all its statements\n  path.ensureBlock();\n\n  // add the value declaration to the new loop body\n  if (declar) {\n    block.body.push(declar);\n  }\n\n  // push the rest of the original loop body onto our new body\n  block.body.push(...(node.body as t.BlockStatement).body);\n\n  t.inherits(loop, node);\n  t.inherits(loop.body, node.body);\n\n  if (build.replaceParent) {\n    path.parentPath.replaceWithMultiple(build.node);\n    path.remove();\n  } else {\n    path.replaceWithMultiple(build.node);\n  }\n}\n\nconst buildForOfLoose = template.statement(`\n  for (var LOOP_OBJECT = OBJECT,\n          IS_ARRAY = Array.isArray(LOOP_OBJECT),\n          INDEX = 0,\n          LOOP_OBJECT = IS_ARRAY ? LOOP_OBJECT : LOOP_OBJECT[Symbol.iterator]();;) {\n    INTERMEDIATE;\n    if (IS_ARRAY) {\n      if (INDEX >= LOOP_OBJECT.length) break;\n      ID = LOOP_OBJECT[INDEX++];\n    } else {\n      INDEX = LOOP_OBJECT.next();\n      if (INDEX.done) break;\n      ID = INDEX.value;\n    }\n  }\n`);\n\nconst buildForOf = template.statements(`\n  var ITERATOR_COMPLETION = true;\n  var ITERATOR_HAD_ERROR_KEY = false;\n  var ITERATOR_ERROR_KEY = undefined;\n  try {\n    for (\n      var ITERATOR_KEY = OBJECT[Symbol.iterator](), STEP_KEY;\n      !(ITERATOR_COMPLETION = (STEP_KEY = ITERATOR_KEY.next()).done);\n      ITERATOR_COMPLETION = true\n    ) {}\n  } catch (err) {\n    ITERATOR_HAD_ERROR_KEY = true;\n    ITERATOR_ERROR_KEY = err;\n  } finally {\n    try {\n      if (!ITERATOR_COMPLETION && ITERATOR_KEY.return != null) {\n        ITERATOR_KEY.return();\n      }\n    } finally {\n      if (ITERATOR_HAD_ERROR_KEY) {\n        throw ITERATOR_ERROR_KEY;\n      }\n    }\n  }\n`);\n\nfunction pushComputedPropsLoose(\n  path: NodePath<t.ForOfStatement>,\n  state: PluginPass,\n) {\n  const { node, scope, parent } = path;\n  const { left } = node;\n  let declar, id, intermediate;\n\n  if (t.isIdentifier(left) || t.isPattern(left) || t.isMemberExpression(left)) {\n    // for (i of test), for ({ i } of test)\n    id = left;\n    intermediate = null;\n  } else if (t.isVariableDeclaration(left)) {\n    // for (let i of test)\n    id = scope.generateUidIdentifier(\"ref\");\n    declar = t.variableDeclaration(left.kind, [\n      t.variableDeclarator(left.declarations[0].id, t.identifier(id.name)),\n    ]);\n    intermediate = t.variableDeclaration(\"var\", [\n      t.variableDeclarator(t.identifier(id.name)),\n    ]);\n  } else {\n    throw state.buildCodeFrameError(\n      left,\n      `Unknown node type ${left.type} in ForStatement`,\n    );\n  }\n\n  const iteratorKey = scope.generateUidIdentifier(\"iterator\");\n  const isArrayKey = scope.generateUidIdentifier(\"isArray\");\n\n  const loop = buildForOfLoose({\n    LOOP_OBJECT: iteratorKey,\n    IS_ARRAY: isArrayKey,\n    OBJECT: node.right,\n    INDEX: scope.generateUidIdentifier(\"i\"),\n    ID: id,\n    INTERMEDIATE: intermediate,\n  }) as t.ForStatement;\n\n  //\n  const isLabeledParent = t.isLabeledStatement(parent);\n  let labeled;\n\n  if (isLabeledParent) {\n    labeled = t.labeledStatement(parent.label, loop);\n  }\n\n  return {\n    replaceParent: isLabeledParent,\n    declar: declar,\n    node: labeled || loop,\n    loop: loop,\n  };\n}\n\nfunction pushComputedPropsSpec(\n  path: NodePath<t.ForOfStatement>,\n  state: PluginPass,\n) {\n  const { node, scope, parent } = path;\n  const left = node.left;\n  let declar;\n\n  const stepKey = scope.generateUid(\"step\");\n  const stepValue = t.memberExpression(\n    t.identifier(stepKey),\n    t.identifier(\"value\"),\n  );\n\n  if (t.isIdentifier(left) || t.isPattern(left) || t.isMemberExpression(left)) {\n    // for (i of test), for ({ i } of test)\n    declar = t.expressionStatement(\n      t.assignmentExpression(\"=\", left, stepValue),\n    );\n  } else if (t.isVariableDeclaration(left)) {\n    // for (let i of test)\n    declar = t.variableDeclaration(left.kind, [\n      t.variableDeclarator(left.declarations[0].id, stepValue),\n    ]);\n  } else {\n    throw state.buildCodeFrameError(\n      left,\n      `Unknown node type ${left.type} in ForStatement`,\n    );\n  }\n\n  const template = buildForOf({\n    ITERATOR_HAD_ERROR_KEY: scope.generateUidIdentifier(\"didIteratorError\"),\n    ITERATOR_COMPLETION: scope.generateUidIdentifier(\n      \"iteratorNormalCompletion\",\n    ),\n    ITERATOR_ERROR_KEY: scope.generateUidIdentifier(\"iteratorError\"),\n    ITERATOR_KEY: scope.generateUidIdentifier(\"iterator\"),\n    STEP_KEY: t.identifier(stepKey),\n    OBJECT: node.right,\n  });\n\n  const isLabeledParent = t.isLabeledStatement(parent);\n\n  const tryBody = (template[3] as t.TryStatement).block.body;\n  const loop = tryBody[0] as t.ForStatement;\n\n  if (isLabeledParent) {\n    tryBody[0] = t.labeledStatement(parent.label, loop);\n  }\n\n  //\n\n  return {\n    replaceParent: isLabeledParent,\n    declar: declar,\n    loop: loop,\n    node: template,\n  };\n}\n"],"mappings":";;;;;;AAAA,IAAAA,KAAA,GAAAC,OAAA;AAOe,SAASC,sBAAsBA,CAC5CC,KAAqB,EACrBC,IAAgC,EAChCC,KAAiB,EACjB;EACA,MAAMC,iBAAiB,GAAGH,KAAK,GAC3BI,sBAAsB,GACtBC,qBAAqB;EAEzB,MAAM;IAAEC;EAAK,CAAC,GAAGL,IAAI;EACrB,MAAMM,KAAK,GAAGJ,iBAAiB,CAACF,IAAI,EAAEC,KAAK,CAAC;EAC5C,MAAMM,